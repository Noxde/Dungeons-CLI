const axios = require("axios");
const path = require("path");
const fs = require("fs");

function backup(savePath) {
  try {
    const backupFolder = path.join(savePath, "..", "backup");
    if (!fs.existsSync(backupFolder)) {
      console.log("Backup folder not found, creating it.");
      fs.mkdirSync(backupFolder, {
        recursive: true,
      });
    }
    console.log("Backup created.");
    fs.copyFileSync(
      savePath,
      path.join(backupFolder, `${path.basename(savePath)}.bak`)
    );
  } catch (error) {
    enterToExit(error);
  }
}

async function checkUpdate(current, remote) {
  if (JSON.stringify(current) === JSON.stringify(remote)) {
    console.log("Dungeons are up to date.");
    return true;
  } else {
    console.log("Dungeons are outdated, using fetched list.");
    return false;
  }
}

async function getRemote() {
  console.log("Fetching list of dungeons.");
  const res = await axios
    .get("https://api.github.com/gists/a29f699f4175bf315d9bd4baeebefb66")
    .catch((e) => null);

  if (!res) return null;

  return JSON.parse(res.data.files["dungeons.json"].content);
}

function findInventory(buffer) {
  for (let i = 0; i < buffer.length; i += 4) {
    if (
      buffer.slice(i, i + 4).compare(Buffer.from([0x40, 0xf0, 0xff, 0xff])) == 0
    ) {
      return i;
    }
  }
}

function replaceDungeon(buffer, option, dungeon, inventory) {
  const start = inventory + 88328 + 0x7d * (option - 1);

  for (let i = 0; i < dungeon.length; i++) {
    buffer[start + i] = dungeon[i];
  }
  setFlag(buffer, option, inventory);
}

function setFlag(buffer, option, inventory) {
  const flags = inventory + 102704 + 0x7d * (option - 1);
  const flag = Buffer.from([
    0x30, 0x00, 0x03, 0xe8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
  ]);

  for (let i = 0; i < flag.length; i++) {
    buffer[flags + i] = flag[i];
  }
}

function isEmptyDungeon(bytes) {
  const empty = Buffer.from([
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
  ]);

  return empty.compare(bytes) === 0;
}

function getDungeon(bytes, inventory, slot) {
  const start = inventory + 88328 + 0x7d * (slot - 1);
  const found = bytes.slice(start, start + 0x7c);

  return found;
}

function getDungeons(bytes, inventory, dungeons) {
  const start = inventory + 88328;
  const flatDungeons = Object.keys(dungeons)
    .map((x) => dungeons[x])
    .flat();

  for (let i = 0; i < 6; i++) {
    const currentDungeon = bytes.slice(
      start + i * 0x7d,
      start + i * 0x7d + 124
    );
    if (isEmptyDungeon(currentDungeon)) {
      console.log(`${i + 1}: Empty`);
      continue;
    }

    const f = flatDungeons.find(
      (x) => currentDungeon.compare(Buffer.from(x.bytes)) == 0
    );

    if (f) {
      console.log(`${i + 1}: ${f.glyph}`);
    } else {
      console.log(`${i + 1}: Dungeon not found in the list`);
    }
  }
}

function findName(bytes, inventory) {
  const start = inventory - 469;
  return bytes.slice(start, start + 32).toString();
}

function enterToExit(message) {
  if (message) {
    console.log(message);
  }

  require("readline")
    .createInterface({
      input: process.stdin,
      output: process.stdout,
    })
    .question("Press enter to close...", () => process.exit(1));
}

module.exports = {
  backup,
  checkUpdate,
  getRemote,
  findInventory,
  getDungeon,
  isEmptyDungeon,
  replaceDungeon,
  getDungeons,
  findName,
  enterToExit,
};
